# 第 13 周 

## Algorithm

#### 1. [实现strStr()](https://leetcode-cn.com/problems/implement-strstr/)

思路： 双索引，i 记录遍历的haystack位置，j记录比较的needle的位置，j等于needle的长度时则全匹配，则返回位置 i-j;当出现匹配不了的，则重置j=0,i=i-j,然后从i+1位置重新开始对比。


    public static int StrStr(string haystack, string needle) {
            if(needle == "")return 0;
            if(string.IsNullOrEmpty(needle) || haystack.Length <needle.Length)return -1;

            var j = 0;var i=0;
            for(i=0;i<haystack.Length;i++)
            {
                if(j == needle.Length)break;
                if(needle.Length-j>haystack.Length-i){
                    j=0;
                    break;
                }
                if( haystack[i] == needle[j])
                {
                    j++;
                }else{
                    i=i-j;
                    j=0;
                }
                
            }
            return j>0?i-j:-1;
        }

#### 2. [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

思路：直接顺序遍历，>=target 时返回索引位置即可，未找到即最大，返回数组长度即可。**也可以使用二分法**

        public static int SearchInsert(int[] nums, int target)
        {
            if(nums.Length == 0)return 0;
            for(int i =0;i<nums.Length;i++)
            {
                if(nums[i]>=target)
                    return i;
            }
            return nums.Length;
        }

#### [3.盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

思路： 首先想到的就是从头到尾遍历一遍就知道最大是多少了，也就是暴力法，嵌套循环。**超时**

        public static int MaxArea(int[] height)
        {
            var maxValue = 0;
            for(int i = 0;i< height.Length-1;i++)
            {
                for(int j =i+1; j<height.Length;j++)
                {
                    maxValue=Math.Max(maxValue,(j-i)*(height[i]>height[j]?height[j]:height[i]));
                }
            }

            return maxValue;
        }        

扩展： 看的题解，双指针法，即从两端向中间推进，谁值小谁移动位置，一次遍历获取到最大值。

        public static int MaxAreaExt(int[] height)
        {
            var maxValue = 0;
            var i =0;
            var j = height.Length-1;
            while(i<j)
            {
                maxValue=Math.Max(maxValue,(j-i)*(height[i]>height[j]?height[j]:height[i]));
                if(height[i]<height[j])
                {
                    i++;
                }
                else{
                    j--;
                }
            }
            return maxValue;
        }
    

## Review

#### 1. [http://kafka.apache.org/intro](http://kafka.apache.org/intro)



## Tip


## Share

